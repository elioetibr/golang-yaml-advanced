name: Release
on: [push, pull_request]

permissions:
  id-token: write
  contents: write
  pull-requests: write

jobs:
  gitversion:
    name: GitVersion
    runs-on: ubuntu-latest
    steps:
      - name: Check out code into the Go module directory
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # Cache GitVersion tool
      - name: Cache GitVersion
        uses: actions/cache@v4
        with:
          path: ~/.dotnet/tools
          key: ${{ runner.os }}-gitversion-6.x
          restore-keys: |
            ${{ runner.os }}-gitversion-

      - name: Install GitVersion
        id: install-gitversion
        uses: gittools/actions/gitversion/setup@v4.1.0
        with:
          versionSpec: '6.x'
          preferLatestVersion: true
      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v4.1.0
    outputs:
      major: ${{ steps.gitversion.outputs.major }}
      minor: ${{ steps.gitversion.outputs.minor }}
      majorMinorPatch: ${{ steps.gitversion.outputs.majorMinorPatch }}
      semVer: ${{ steps.gitversion.outputs.semVer }}
      version: ${{ github.ref_name == github.event.repository.default_branch && steps.gitversion.outputs.majorMinorPatch || steps.gitversion.outputs.semVer }}

  test:
    name: Test
    runs-on: ${{ matrix.os }}
    needs: [ gitversion ]
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-latest
          - macos-latest
          - windows-2025  # Use Windows Server 2025 to be future-proof
        arch:
          - amd64
          - arm64
        go:
          - "1.22"
          - "1.23"
          - "1.24"
          - "1.25"
        exclude:
          # Windows doesn't support ARM64 runners on GitHub Actions
          - os: windows-2025
            arch: arm64
    steps:
      - name: Check out code into the Go module directory
        uses: actions/checkout@v5
        with:
          submodules: recursive

      # Set cache paths based on OS
      - name: Set cache paths
        id: cache-paths
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            echo "GOMODCACHE=${USERPROFILE}\go\pkg\mod" >> $GITHUB_OUTPUT
            echo "GOCACHE=${LOCALAPPDATA}\go-build" >> $GITHUB_OUTPUT
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            echo "GOMODCACHE=${HOME}/go/pkg/mod" >> $GITHUB_OUTPUT
            echo "GOCACHE=${HOME}/Library/Caches/go-build" >> $GITHUB_OUTPUT
          else
            echo "GOMODCACHE=${HOME}/go/pkg/mod" >> $GITHUB_OUTPUT
            echo "GOCACHE=${HOME}/.cache/go-build" >> $GITHUB_OUTPUT
          fi

      # Cache Go modules and build cache
      - name: Cache Go modules
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ${{ steps.cache-paths.outputs.GOMODCACHE }}
            ${{ steps.cache-paths.outputs.GOCACHE }}
          key: ${{ runner.os }}-${{ matrix.arch }}-go-${{ matrix.go }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.arch }}-go-${{ matrix.go }}-

      - name: Set up Go ${{ matrix.go }}
        uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go }}
          check-latest: true
          cache: false  # Disable built-in cache as we use our own

      - name: Go Version
        run: go version

      - name: Go Vet
        run: go vet ./...

      - name: Run tests with coverage and race detection
        shell: bash
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./ 2>&1 | tee test-output.txt
          echo "TEST_EXIT_CODE=${PIPESTATUS[0]}" >> $GITHUB_ENV

      - name: Generate test summary
        if: always()
        shell: bash
        run: |
          cat > test-summary.md << 'EOF'
          # Test Results Summary 📊

          ## Configuration
          - **Go Version:** ${{ matrix.go }}
          - **OS:** ${{ runner.os }}
          - **Architecture:** ${{ matrix.arch }}
          - **Commit:** ${{ github.sha }}
          - **Branch:** ${{ github.ref_name }}

          ## Test Execution Results
          EOF

          # Parse test output for summary
          if [ -f test-output.txt ]; then
            # Count test results
            TOTAL_PACKAGES=$(grep -c "^ok\|^FAIL" test-output.txt || echo 0)
            PASSED_PACKAGES=$(grep -c "^ok" test-output.txt || echo 0)
            FAILED_PACKAGES=$(grep -c "^FAIL" test-output.txt || echo 0)
            SKIPPED_TESTS=$(grep -c "SKIP" test-output.txt || echo 0)

            # Extract timing information
            TOTAL_TIME=$(grep "^ok\|^FAIL" test-output.txt | awk '{sum+=$NF} END {printf "%.3f", sum}' || echo "0")

            cat >> test-summary.md << EOF

          ### Package Summary
          | Metric | Value |
          |--------|-------|
          | Total Packages | $TOTAL_PACKAGES |
          | ✅ Passed | $PASSED_PACKAGES |
          | ❌ Failed | $FAILED_PACKAGES |
          | ⏭️ Skipped Tests | $SKIPPED_TESTS |
          | ⏱️ Total Time | ${TOTAL_TIME}s |

          EOF

            # Add detailed results
            echo "### Detailed Package Results" >> test-summary.md
            echo "| Package | Status | Duration | Coverage |" >> test-summary.md
            echo "|---------|--------|----------|----------|" >> test-summary.md

            while IFS= read -r line; do
              if [[ $line =~ ^(ok|FAIL)[[:space:]]+(github.com[^[:space:]]+)[[:space:]]+([0-9.]+s) ]]; then
                STATUS="${BASH_REMATCH[1]}"
                PACKAGE="${BASH_REMATCH[2]}"
                DURATION="${BASH_REMATCH[3]}"

                # Get coverage for this package if available
                COVERAGE=$(grep "coverage:" test-output.txt | grep "$PACKAGE" | sed -n 's/.*coverage: \([0-9.]*\)%.*/\1%/p' | head -1 || echo "N/A")

                if [ "$STATUS" == "ok" ]; then
                  STATUS_ICON="✅"
                else
                  STATUS_ICON="❌"
                fi

                # Shorten package name for readability
                SHORT_PACKAGE=$(echo "$PACKAGE" | sed 's|github.com/elioetibr/golang-yaml-advanced/||')
                echo "| $SHORT_PACKAGE | $STATUS_ICON $STATUS | $DURATION | $COVERAGE |" >> test-summary.md
              fi
            done < test-output.txt

            # Add any test failures
            if [ "$FAILED_PACKAGES" -gt 0 ]; then
              echo "" >> test-summary.md
              echo "### ❌ Test Failures" >> test-summary.md
              echo '```' >> test-summary.md
              grep -A 5 "FAIL:" test-output.txt || true
              echo '```' >> test-summary.md
            fi

            # Add any race conditions detected
            if grep -q "WARNING: DATA RACE" test-output.txt; then
              echo "" >> test-summary.md
              echo "### ⚠️ Race Conditions Detected" >> test-summary.md
              echo '```' >> test-summary.md
              grep -A 10 "WARNING: DATA RACE" test-output.txt || true
              echo '```' >> test-summary.md
            fi
          fi

          # Output the summary
          cat test-summary.md >> $GITHUB_STEP_SUMMARY

      - name: Calculate coverage percentage
        if: always()
        shell: bash
        run: |
          if [ -f coverage.out ]; then
            COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
            echo "COVERAGE=$COVERAGE" >> $GITHUB_ENV
            echo "### 📊 Total Test Coverage: $COVERAGE" >> $GITHUB_STEP_SUMMARY

            # Add coverage breakdown by package (aggregated)
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Coverage by Package" >> $GITHUB_STEP_SUMMARY
            echo "| Package | Files | Average Coverage |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|-------|------------------|" >> $GITHUB_STEP_SUMMARY

            # Aggregate coverage by package directory
            go tool cover -func=coverage.out | grep -v "total:" | grep "github.com" | awk '
            {
              # Extract package path (remove filename)
              split($1, parts, "/")
              pkg = ""
              for (i=1; i<length(parts); i++) {
                if (i>1) pkg = pkg "/"
                pkg = pkg parts[i]
              }

              # Remove base path
              gsub(/^github\.com\/elioetibr\/golang-yaml-advanced\//, "", pkg)
              if (pkg == "") pkg = "root"

              # Extract coverage percentage
              gsub(/%/, "", $3)
              coverage[pkg] += $3
              count[pkg]++
            }
            END {
              for (pkg in coverage) {
                avg = coverage[pkg] / count[pkg]
                printf "| %s | %d | %.1f%% |\n", pkg, count[pkg], avg
              }
            }' | sort >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload test coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.os }}-${{ matrix.arch }}-go${{ matrix.go }}
          path: coverage.out
          retention-days: 7

      - name: Upload test results artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-${{ matrix.arch }}-go${{ matrix.go }}
          path: test-output.txt
          retention-days: 7

      - name: Check test results
        if: always()
        shell: bash
        run: |
          if [ "${TEST_EXIT_CODE}" != "0" ]; then
            echo "❌ Tests failed with exit code ${TEST_EXIT_CODE}" >> $GITHUB_STEP_SUMMARY
            exit ${TEST_EXIT_CODE}
          else
            echo "✅ All tests passed successfully!" >> $GITHUB_STEP_SUMMARY
          fi

  release:
    name: Release
    if: ${{ success() && github.ref_name == github.event.repository.default_branch }}
    runs-on: ubuntu-latest
    needs: [ gitversion, test ]
    steps:
      - name: GitHub Actions Bot Configuration
        id: bot_config
        env:
          GITHUB_BOT_EMAIL: elio@elio.eti.br
          GITHUB_BOT_USERNAME: Elio Severo Junior
        shell: bash -l {0}
        run: |
          #!/usr/bin/env bash
          
          set -euo pipefail
          
          echo "GITHUB_BOT_EMAIL=${{ env.GITHUB_BOT_EMAIL }}" >> $GITHUB_ENV
          echo "GITHUB_BOT_USERNAME=${{ env.GITHUB_BOT_USERNAME }}" >> $GITHUB_ENV
          
          git config --global author.email "${{ env.GITHUB_BOT_EMAIL }}"
          git config --global author.name "${{ env.GITHUB_BOT_USERNAME }}"
          git config --global committer.email "${{ env.GITHUB_BOT_EMAIL }}"
          git config --global committer.name "${{ env.GITHUB_BOT_USERNAME }}"
          git config --global init.defaultBranch ${{ github.event.repository.default_branch }}
          git config --global pull.ff only
          git config --global pull.rebase true
          git config --global push.autosetupremote true
          git config --global push.followTags true
          git config --global user.email "${{ env.GITHUB_BOT_EMAIL }}"
          git config --global user.name "${{ env.GITHUB_BOT_USERNAME }}"
          
          if [[ "${{ github.event.act }}" == "true" ]];
          then
          echo "Disabling GPG Configurations..."
          git config --local --unset commit.gpgsign 2>/dev/null
          git config --local --unset gpg.program 2>/dev/null
          git config --local --unset user.signingkey 2>/dev/null
          else
          echo "Initializing Git Repository..."
          git init ${{ github.workspace }}
          fi
          
          echo "bot_email=${{ env.GITHUB_BOT_EMAIL }}" >> $GITHUB_OUTPUT
          echo "bot_user=${{ env.GITHUB_BOT_USERNAME }}" >> $GITHUB_OUTPUT

      - name: Generate GitHub App Token
        uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: Check out code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Tag
        id: tag
        shell: bash -l {0}
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          #!/usr/bin/env bash
          
          function tagger() {
            VERSION=$1
            echo "Releasing Version: ${VERSION}"
            TAG_EXISTS=$(git ls-remote -q --tags | grep -q "refs/tags/${VERSION}$" && echo true || echo false)
            if [[ "${TAG_EXISTS}" = true ]];
            then
              HAS_RELEASE=$(gh release list --json tagName -q '.[].tagName' | grep -E "^(${VERSION})$" && echo true || echo false)
              if [[ "${HAS_RELEASE}" == true ]];
              then
                gh release delete --yes ${VERSION}
              fi
              git push origin --delete ${VERSION}
              git tag -d ${VERSION}
            fi
          
            echo
            git tag -a ${VERSION} -m "chore: Release Version ${VERSION}"
            git push -f --tags --follow-tags
            git push --set-upstream origin ${{ github.ref_name }}
            echo
            echo
          }
          
          tagger "v${{ needs.gitversion.outputs.version }}"
          if [[ "${{ github.ref_name  }}" == "${{ github.event.repository.default_branch }}" ]];
          then
            tagger "v${{ needs.gitversion.outputs.major }}.${{ needs.gitversion.outputs.minor }}"
            tagger "v${{ needs.gitversion.outputs.major }}"
          fi

      - name: Release
        id: release
        shell: bash -l {0}
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          #!/usr/bin/env bash
          
          if [[ "${{ github.ref_name  }}" == "${{ github.event.repository.default_branch }}" ]];
          then
            gh release list | grep Draft | awk '{print $1 " \t"}' | while read -r draft; do echo "Removing Draft Releases: ${draft}"; gh release delete --yes "${draft}"; done
            gh release create v${{ needs.gitversion.outputs.version }} --generate-notes --verify-tag --latest
          fi
